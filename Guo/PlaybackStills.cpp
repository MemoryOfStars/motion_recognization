/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
#define VIDEO_WIDTH  1920
#define VIDEO_HEIGHT 1080

#define SHM_LEN 8
#define YUV_SIZE 3*VIDEO_WIDTH*VIDEO_HEIGHT/2
#define RGB_SIZE 4*VIDEO_WIDTH*VIDEO_HEIGHT
#define SHM_KEY_YUV 67483
#define SHM_KEY_RGB 67484
#define SHM_SIZE_YUV YUV_SIZE*SHM_LEN + 32
#define SHM_SIZE_RGB RGB_SIZE*SHM_LEN + 32

#define OUTPUT_FORMAT AV_PIX_FMT_YUV420P 
#define SAVE_FILE    true

#include <stdio.h>
#include <thread>
#include <chrono>
#include <mutex>
#include <condition_variable>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "platform.h"
#include "ImageLoader.h"
#include "DeckLinkAPI.h"
#include "rte_ring.h"

extern "C"  
{  
#include "libavcodec/avcodec.h"  
#include "libavformat/avformat.h"  
#include "libswscale/swscale.h"  
#include "libavutil/imgutils.h"  
};  
  
#pragma comment(lib, "avcodec.lib")  
#pragma comment(lib, "avformat.lib")  
#pragma comment(lib, "swscale.lib")  
#pragma comment(lib, "avutil.lib") 
#pragma pack (1)


typedef struct hiFrameInfo
{
    char type;
    int  len;
    int vid;                       //Video ID
    int fid;                       //Frame ID
}FrameInfo;

std::mutex					g_playbackMutex;
std::condition_variable		g_playbackStopCondition;
bool						g_keyPressed = false;

struct rte_ring* ring_yuv = NULL;
struct rte_ring* ring_rgb = NULL;




void decode()
{
	AVFormatContext             *pFormatCtx         = NULL;  
    AVCodecContext              *pCodecCtx          = NULL;  
    AVCodec                     *pCodec             = NULL;  
    AVFrame                     *pFrame             = NULL, *pFrameYUV = NULL;
	char                        filepath[]          = "video.mp4"; 

	unsigned char               *out_buffer         = NULL;  
    AVPacket                    packet;  
    struct SwsContext           *img_convert_ctx    = NULL;  
    int                         got_picture;  
    int                         videoIndex;  
    int                         frame_cnt           = 1;
    FILE*                       yuv_file            = NULL;
	
	void*                       yuvData             = malloc(3*VIDEO_WIDTH*VIDEO_HEIGHT/2);
	
	av_register_all();  
  
    if (avformat_open_input(&pFormatCtx, filepath, NULL, NULL) != 0){  
        printf("Couldn't open an input stream.\n");  
        return -1;  
    }  
    if (avformat_find_stream_info(pFormatCtx, NULL) < 0){  
        printf("Couldn't find stream information.\n");  
        return -1;  
    }  
    videoIndex = -1;  
    for (int i = 0; i < pFormatCtx->nb_streams; i++)  
        if (pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO){  
            videoIndex = i;  
            break;  
        }
  
    if (videoIndex == -1){  
        printf("Couldn't find a video stream.\n");  
        return -1;  
    }
  
    pCodecCtx = pFormatCtx->streams[videoIndex]->codec;  
    pCodec = avcodec_find_decoder(pCodecCtx->codec_id);  
    if (pCodec == NULL){  
        printf("Codec not found.\n");  
        return -1;  
    }  
    if (avcodec_open2(pCodecCtx, pCodec, NULL) < 0){  
        printf("Could not open codec.\n");  
        return -1;  
    }  
 

    pFrame = av_frame_alloc();  
    pFrameYUV = av_frame_alloc();  
    if (pFrame == NULL || pFrameYUV == NULL)  
    {  
        printf("memory allocation error\n");  
        return -1;  
    }  
  
    /** 
    *  RGB--------->AV_PIX_FMT_RGB24 
    *  YUV420P----->AV_PIX_FMT_YUV420P 
    *  UYVY422----->AV_PIX_FMT_UYVY422 
    *  YUV422P----->AV_PIX_FMT_YUV422P 
    */ 
    out_buffer = (unsigned char *)av_malloc(av_image_get_buffer_size(OUTPUT_FORMAT, pCodecCtx->width, pCodecCtx->height, 1));  
    av_image_fill_arrays(pFrameYUV->data, pFrameYUV->linesize, out_buffer,  
        OUTPUT_FORMAT, pCodecCtx->width, pCodecCtx->height, 1);  
    img_convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height, pCodecCtx->pix_fmt,  
        pCodecCtx->width, pCodecCtx->height, OUTPUT_FORMAT, SWS_BICUBIC, NULL, NULL, NULL);
	
	while (av_read_frame(pFormatCtx, &packet) >= 0)
	{
		if (packet.stream_index == videoIndex)                                     
        {  
            if (avcodec_decode_video2(pCodecCtx, pFrame, &got_picture, &packet) < 0)  
            {  
                printf("Decode Error.\n");  
                return -1;  
            }  
            if (got_picture)  
            {  
                char filename[100];
                sprintf(filename, "./YUV/%d.yuv", frame_cnt);
                yuv_file = fopen(filename, "wb");
                sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame->data, pFrame->linesize, 0, pCodecCtx->height,  
                    pFrameYUV->data, pFrameYUV->linesize);  
  
                //输出出YUV数据 
                
				memcpy(yuvData, pFrameYUV->data[0], VIDEO_WIDTH*VIDEO_HEIGHT);
				memcpy(yuvData + VIDEO_WIDTH*VIDEO_HEIGHT, pFrameYUV->data[1], VIDEO_WIDTH*VIDEO_HEIGHT/4);
				memcpy(yuvData + 5*VIDEO_WIDTH*VIDEO_HEIGHT/4, pFrameYUV->data[2], VIDEO_WIDTH*VIDEO_HEIGHT/4);
				fwrite(yuvData, YUV_SIZE, 1, yuv_file);
				while(rte_ring_enqueue(ring_yuv, yuvData) != 1)
				{
					continue;
				}
                ring_info(ring_yuv);
                frame_cnt++;  
                fclose(yuv_file);
            }  
        }  
        av_free_packet(&packet);  

	}
}

void PlaybackStills(IDeckLinkOutput* deckLinkOutput, IDeckLinkVideoFrame* playbackFrame, long updateIntervalms, bool loopPlayback)
{
	std::chrono::milliseconds	timerPeriod(updateIntervalms);
	int							playbackStillsCount	= 0;
	bool						playbackRunning		= true;
	HRESULT						result				= S_OK;
    int                         nframe              = 0;

	uint8_t*	                deckLinkBuffer	    = nullptr;                             //数据地址
	int                         frame_cnt           = 1;
	
	void*                       rgbData             = malloc(4*VIDEO_WIDTH*VIDEO_HEIGHT);
    
	

	result = playbackFrame->GetBytes((void**)&deckLinkBuffer); //得到Frame数据结构的data buffer地址

	if (result != S_OK)
	{
		fprintf(stderr, "Error reading PNG file: %s\n");
		playbackRunning = false;
	}
	while(1)
	{
		while(rte_ring_dequeue(ring_rgb, &rgbData) != 1)
		{
			continue;
		}
		memset(deckLinkBuffer, 0, VIDEO_WIDTH*VIDEO_HEIGHT*4);
		memcpy(deckLinkBuffer, rgbData, VIDEO_WIDTH*VIDEO_HEIGHT*4);
		//if(SAVE_FILE)
		//{
		//    fwrite(yuvData, VIDEO_WIDTH*VIDEO_HEIGHT*2, 1, yuv_file);
		//}
		
		result = deckLinkOutput->DisplayVideoFrameSync(playbackFrame);              //播放playbackFrame这一帧
		if (result != S_OK)
		{
			fprintf(stderr, "Unable to display video output\n");
			playbackRunning = false;
		}
		else
		{
			printf("display success :%d\n", frame_cnt);
			frame_cnt++;
		}
	}
		
}




int main(int argc, char* argv[])
{
	// Configuration flags
	bool						displayHelp			= false;
	int							deckLinkIndex		= -1;
	int							displayModeIndex	= 2;
	bool						loopPlayback		= false;
	int							updateInterval		= 1;
	int                         Idx                 = 0;
	HRESULT						result;
	int							exitStatus = 1;

	std::thread					playbackStillsThread;
	std::thread					decodeThread;

	IDeckLinkIterator*			deckLinkIterator		= NULL;
	IDeckLink*					deckLink				= NULL;
	IDeckLinkOutput*			selectedDeckLinkOutput	= NULL;
	IDeckLinkMutableVideoFrame*	playbackFrame			= NULL;

	BMDDisplayMode				selectedDisplayMode		= bmdModeHD1080p2398;
	std::string					selectedDisplayModeName;
	BMDTimeValue				frameDuration			= 1001;
	BMDTimeValue				frameTimescale			= 24000;

	std::vector<IDeckLinkDisplayMode*>	displayModes;
	std::vector<std::string>			deckLinkDeviceNames;
	std::vector<std::string>			pngFiles;

	int shmid_yuv = 0;
	int shmid_rgb = 0;
	char* shm_yuv = NULL;
	char* shm_rgb = NULL;
	
	shmid_yuv = shmget(SHM_KEY_YUV, SHM_SIZE_YUV, 0666|IPC_CREAT);
	shmid_rgb = shmget(SHM_KEY_RGB, SHM_SIZE_RGB, 0666|IPC_CREAT);
	
	shm_yuv = (char*)shmat(shmid_yuv, NULL, 0);
	shm_rgb = (char*)shmat(shmid_rgb, NULL, 0);
	if((int)shm_yuv == -1 || (int)shm_rgb == -1)
	{
		printf("Share memory can't get pointer\n");
		return;
	}
    memset(shm_yuv, 0, SHM_SIZE_YUV);
    memset(shm_rgb, 0, SHM_SIZE_RGB);

	result = GetDeckLinkIterator(&deckLinkIterator);     //get到Decklink设备
	if (result != S_OK)
		goto bail;

	Idx = 0;
	while ((result = deckLinkIterator->Next(&deckLink)) == S_OK)
	{
		dlstring_t deckLinkName;

		result = deckLink->GetDisplayName(&deckLinkName);
		if (result == S_OK)
		{
			deckLinkDeviceNames.push_back(DlToStdString(deckLinkName));//得到所有设备的名称
			DeleteString(deckLinkName);
		}
		
        if(Idx == 4)
		{
			// Check that selected device supports playback
			IDeckLinkProfileAttributes*	deckLinkAttributes = NULL;
			int64_t						ioSupportAttribute = 0;

			result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);

			if (result != S_OK)
			{
				fprintf(stderr, "Unable to get IDeckLinkAttributes interface\n");
				goto bail;
			}

			if (deckLinkAttributes->GetInt(BMDDeckLinkVideoIOSupport, &ioSupportAttribute) != S_OK)   //获取iosupport参数(检查设备是否支持playback)
				ioSupportAttribute = 0;

			deckLinkAttributes->Release();

			if ((ioSupportAttribute & bmdDeviceSupportsPlayback) != 0)                  //所选设备支持playback
			{
				result = deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&selectedDeckLinkOutput);//得到decklink设备的output口
				if (result != S_OK)
				{
					fprintf(stderr, "Unable to get IDeckLinkOutput interface\n");
					goto bail;
				}
			}
			else
			{
				fprintf(stderr, "Selected device does not support playback\n");
				displayHelp = true;
			}
		}
		Idx ++;
		deckLink->Release();
		deckLink = NULL;
	}

	// Get display modes from the selected decklink output 
	if (selectedDeckLinkOutput != NULL)
	{
		IDeckLinkDisplayModeIterator* displayModeIterator;
		IDeckLinkDisplayMode* displayMode;

		result = selectedDeckLinkOutput->GetDisplayModeIterator(&displayModeIterator);
		if (result != S_OK)
		{
			fprintf(stderr, "Unable to get IDeckLinkDisplayModeIterator interface\n");
			goto bail;
		}

		while (displayModeIterator->Next(&displayMode) == S_OK)
		{
			displayModes.push_back(displayMode);                   //把选中的output口支持的displayMode都入队列读出来
		}

		displayModeIterator->Release();

		if ((displayModeIndex < 0) || (displayModeIndex > (int)displayModes.size()))//检测用户指定的 输出模式Index 是否合法
		{
			fprintf(stderr, "You must select a valid display mode\n");
			displayHelp = true;
		}
		else
		{ 
			dlbool_t				displayModeSupported;
			dlstring_t				displayModeName;

			result = displayModes[displayModeIndex]->GetName(&displayModeName);
			if (result != S_OK)
				goto bail;

			selectedDisplayModeName = DlToStdString(displayModeName);
			DeleteString(displayModeName);

			selectedDisplayMode = displayModes[displayModeIndex]->GetDisplayMode();

			result = displayModes[displayModeIndex]->GetFrameRate(&frameDuration, &frameTimescale);
			if (result != S_OK)
				goto bail;

			// Check display mode is supported with given options  检查给出的display mode是否支持
			// Passing pixel format = 0 to represent any pixel format
			result = selectedDeckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, selectedDisplayMode, bmdFormatUnspecified, bmdSupportedVideoModeDefault, NULL, &displayModeSupported);
			if ((result != S_OK) || (!displayModeSupported))
			{
				fprintf(stderr, "The display mode %s is not supported by device\n", selectedDisplayModeName.c_str());
				displayHelp = true;
			}
		}
	}

	if (displayHelp)
	{
		fprintf(stderr, "Initial Error\n");
		goto bail;
	}

	// Set the video output mode
	result = selectedDeckLinkOutput->EnableVideoOutput(selectedDisplayMode, bmdVideoOutputFlagDefault);
	if (result != S_OK)
	{
		fprintf(stderr, "Unable to enable video output\n");
		goto bail;
	}
	
	// Create video frame for playback, as we are outputting frame synchronously, 
	// then we can reuse without waiting on callback 
	result = selectedDeckLinkOutput->CreateVideoFrame((int32_t)displayModes[displayModeIndex]->GetWidth(),
													  (int32_t)displayModes[displayModeIndex]->GetHeight(),
													  (int32_t)displayModes[displayModeIndex]->GetWidth() * 4,
													  ImageLoader::kImageLoaderPixelFormat,    //ARGB
													  bmdFrameFlagDefault,
													  &playbackFrame);
	if (result != S_OK)
	{
		fprintf(stderr, "Unable to create video frame\n");
		goto bail;
	}
	
	// OK to start playback - print configuration
	fprintf(stderr, "Output with the following configuration:\n"
		" - Playback device: %s\n"
		" - Video mode: %s\n"
		" - Playback update interval: %d\n"
		" - Loop Playback: %s\n",
		deckLinkDeviceNames[Idx].c_str(),
		selectedDisplayModeName.c_str(),
		updateInterval,
		loopPlayback ? "YES" : "NO"
		);
	fprintf(stderr, "Starting Playback, press <RETURN> to exit\n");

	ring_yuv = (struct rte_ring*)malloc(sizeof(struct rte_ring));
	ring_rgb = (struct rte_ring*)malloc(sizeof(struct rte_ring));
	
	rte_ring_create(ring_yuv, shm_yuv, SHM_SIZE_YUV, YUV_SIZE);
	rte_ring_create(ring_rgb, shm_rgb, SHM_SIZE_RGB, RGB_SIZE);
	
	
	// Start thread for message processing   开始playback线程
	playbackStillsThread = std::thread([&]{
		PlaybackStills(selectedDeckLinkOutput, (IDeckLinkVideoFrame*)playbackFrame,
						updateInterval * 1000 * (long)frameDuration / (long)frameTimescale, loopPlayback);
	});
	
	decodeThread = std::thread([&]{
		decode();
	});
	
	
	
	// Wait on return press, then notify playback thread to finalize
	getchar();
	{
		std::lock_guard<std::mutex> lock(g_playbackMutex);
		g_keyPressed = true;
	}
	g_playbackStopCondition.notify_one();
	playbackStillsThread.join();

	fprintf(stderr, "Stopping Playback\n");
	result = selectedDeckLinkOutput->DisableVideoOutput();   //关闭 视频输出使能
	if (result != S_OK)
		goto bail;

	exitStatus = 0;

bail:
	while (!displayModes.empty())
	{
		displayModes.back()->Release();
		displayModes.pop_back();
	}
	
	if (playbackFrame != NULL)
	{
		playbackFrame->Release();
		playbackFrame = NULL;
	}

	if (selectedDeckLinkOutput != NULL)
	{
		selectedDeckLinkOutput->Release();
		selectedDeckLinkOutput = NULL;
	}

	if (deckLinkIterator != NULL)
	{
		deckLinkIterator->Release();
		deckLinkIterator = NULL;
	}

	return exitStatus;
}

